from keras.models import load_model
import cv2
import numpy as np
import time

# Configurações das câmeras
urls_rtsp = [
    'rtsp://10.8.104.23/streaming/channels/1',
    'rtsp://10.8.104.28/streaming/channels/1',
    'rtsp://10.8.104.38/streaming/channels/1',
    'rtsp://10.8.104.48/streaming/channels/1',
    'rtsp://root:C@meras5522@10.8.107.50/axis-media/media.amp?videocodec=h264',
    'rtsp://root:C@meras5522@10.8.105.37/axis-media/media.amp?videocodec=h264'
]

# Carregar ROIs de um arquivo de texto
caminho_arquivo_rois = 'ROI_MESAS.txt'
rois = []
with open(caminho_arquivo_rois, 'r') as arquivo:
    for linha in arquivo:
        pontos = linha.strip().split(';')
        roi = [tuple(map(int, ponto.split(','))) for ponto in pontos]
        rois.append(np.array(roi, dtype=np.int32))

# Carregar o modelo e os rótulos
model = load_model("keras_Model.h5", compile=False)
class_names = [line.strip() for line in open("labels.txt", "r").readlines()]

# Configurações da tela de saída
screen_height = 600
screen_width = 1200
output_screen = np.zeros((screen_height, screen_width, 3), dtype=np.uint8)

def processar_frame(frame, roi, index):
    # Desenhar o ROI no frame original
    cv2.polylines(frame, [roi], isClosed=True, color=(0, 255, 0), thickness=2)
    
    # Preparar o ROI para previsão
    mask = np.zeros_like(frame)
    cv2.fillPoly(mask, [roi], (255, 255, 255))
    roi_frame = cv2.bitwise_and(frame, mask)
    x, y, w, h = cv2.boundingRect(roi)
    image = cv2.resize(roi_frame[y:y+h, x:x+w], (224, 224), interpolation=cv2.INTER_AREA)
    image = np.asarray(image, dtype=np.float32).reshape(1, 224, 224, 3)
    image /= 127.5
    image -= 1.0

    # Realizar previsão
    prediction = model.predict(image)
    class_name = class_names[np.argmax(prediction)]
    confidence_score = np.max(prediction)

    # Exibir os resultados da previsão
    font_scale = h / 200  # Ajuste conforme necessário
    if index>3:
        font_scale = h / 150  # Ajuste conforme necessário
    font_thickness = 2 #max(1, int(font_scale * 3))
    text = f"{class_name}"# - {confidence_score:.2f}"
    text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, font_scale, font_thickness)[0]

    text_position = (max(5, x - 100), max(20, y - 10))  # Evitar que o texto saia do frame
    #cv2.putText(frame, text, text_position, cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0, 0, 255), font_thickness)
    
        # Desenhar retângulo preto como fundo do texto
    cv2.rectangle(frame, (text_position[0], text_position[1] - text_size[1] - 3),
                  (text_position[0] + text_size[0], text_position[1]), (0, 0, 0), -1)

    # Exibir os resultados da previsão com o texto sobre o retângulo preto
    cv2.putText(frame, text, text_position, cv2.FONT_HERSHEY_SIMPLEX, font_scale, (255, 255, 255), font_thickness)
    


    # Redimensionar o frame processado e posicionar na tela de saída
    rows = 2
    cols = 3
    tile_w = screen_width // cols
    tile_h = screen_height // rows
    position_x = (index % cols) * tile_w
    position_y = (index // cols) * tile_h
    resized_frame = cv2.resize(frame, (tile_w, tile_h))
    output_screen[position_y:position_y+tile_h, position_x:position_x+tile_w] = resized_frame

def main():
    caps = [cv2.VideoCapture(url) for url in urls_rtsp]

    while True:
        output_screen.fill(0)  # Limpar a tela antes de atualizar
        for index, cap in enumerate(caps):
            ret, frame = cap.read()
            if ret:
                processar_frame(frame, rois[index], index)
        
        cv2.imshow("Analise de Cameras", output_screen)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Liberar todos os recursos ao final
    for cap in caps:
        cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
